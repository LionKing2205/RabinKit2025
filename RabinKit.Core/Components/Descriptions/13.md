**Задание 1.3**. 
Разработать блочную программу проверки числа на простоту тестом Миллера-Рабина 
---
---
Реализация:
---
1.	Выбрать оптимальное количество итераций алгоритма k.
2.	Проверка на небольшие числа: если число меньше 2, оно не простое; если 2 или 3, оно простое.
3.	Проверка четности: если число четное и больше 2, оно составное.
4.	Разложение p-1 на 2^s * d: где d нечетное  .
5.	Проведение испытаний: для k случайных оснований:
 
    •	Генерация случайного числа a от 2 до p-2. 

    •	Вычисление x = a^d mod p. 

    •	Если x равно 1 или p-1, переход к следующему основанию. 

    •	Повторение s раз: 

    •	Если x не равно p-1, вычисляем x = x^2 mod p. 

    •	Если x снова не равно p-1 и это последний шаг, число составное.


Примерный код будет выглядеть так:

1. Создайте переменные:
   • p (входное число)
   • s (количество двойных делений)
   • d (нечетная часть)
   • k (количество испытаний)
   • a, x (переменные для оснований и результатов)

2. Запросите значение p у пользователя.

3. Добавьте условие:
   • Если p < 2, выведите "Не простое".
   • Если p == 2 или p == 3, выведите "Простое".
   • Если p % 2 == 0, выведите "Составное".

4. Инициализируйте переменные s и d:
   • Установите d = p - 1.
   • Установите s = 0.
   • В цикле (пока d четное и > 0):
     • Уменьшайте d в 2 раза (d=округлить к меньшему (d / 2)).
     • Увеличивайте s на 1.

5. Установите k.

6. Создайте внешний цикл для k испытаний
   • Генерируйте случайное число a от 2 до p-2.
   • Вычислите x = (a^d) mod p.

7. Добавьте условие:
   • Если x равно 1 или p-1, переходите к следующему испытанию.

8. Создайте внутренний цикл для s-1:
   • Внутри этого цикла добавьте условие:
     • Если x равно p-1, выход из внутреннего цикла.
     • Иначе, обновите x: x = (x^2) mod p.
     Для внешнего цикла Если x не равно p-1 и это последний шаг, выведите "Составное" и завершите программу.

9. Если все испытания пройдены, выведите "Вероятно простое".

---
Задания и вопросы:
---
Какое количество итераций алгоритма вы выбрали? Почему? Какова вероятность ошибки алгоритма?

Сделайте аналогичные 1.2 тесты для числа 561. Что обнаружили?
